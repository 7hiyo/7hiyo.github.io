<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Z5LINK创赢未来]]></title>
  <link href="http://7hiyo.github.io/atom.xml" rel="self"/>
  <link href="http://7hiyo.github.io/"/>
  <updated>2014-04-22T16:32:18+08:00</updated>
  <id>http://7hiyo.github.io/</id>
  <author>
    <name><![CDATA[Z5LINK.Inc]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[baidu intelligent]]></title>
    <link href="http://7hiyo.github.io/blog/2014/04/22/baidu-intelligent/"/>
    <updated>2014-04-22T16:18:44+08:00</updated>
    <id>http://7hiyo.github.io/blog/2014/04/22/baidu-intelligent</id>
    <content type="html"><![CDATA[<h1>百度，能否成为智能硬件的神盾局？</h1>

<hr />

<blockquote><p>编者语：编者最近迷上了神盾局，周末晚上看到五点多，牛逼闪闪的神盾局，中国什么时候也能有呢，还是已经有了只是神秘的很。</p></blockquote>

<p><alt><img src="http://image.woshipm.com/wp-files/2014/04/223.jpg" alt="image" /></alt></p>

<p>如果你在走进电影院之前，没有看过任何漫威的漫画或者影片，那么你完全可以把《美国队长2》当做一部智能硬件的大手笔宣传片。特别是神盾局黑大叔尼克-弗瑞在街头开车逃亡的那一幕，将众多热门技术完美的融合在一起，让人不由衷的感叹，“当领导就是好，自己可以开着如此牛B的智能汽车，手下只能手拿着一个破盾牌四处挡子弹。”</p>

<!-- more -->


<p>在任何一部科幻或者动作大片中，街头飙车追逐都属于常规戏份，但是尼克大叔的爱车却给了人耳目一新的感觉。首先是智能定损系统，子弹打在玻璃上，系统马上计算出受损程度以及部位，这对于观众来说，所有人的心脏都被紧紧抓住，都在想在狂风暴雨的子弹袭击中，到底还能撑多久。其次是自动驾驶与导航系统，非常快的速度规划出最佳路线，并且能在大叔操起机关枪的时候，汽车自动行驶。最牛的当属语音识别系统，整个过程中，我们会发现车里的显示屏只是用来显示信息用的，并不负担任何信息输入的任务。所有的人机交互都是依靠正常的对话完成，说一句话，车就开始跑了。尼克大叔甚至下了句”起飞“的命令，只可惜当时车辆受损严重，无法起飞，否则的话，这一技术一定会让所有被堵在路上的司机们口水直流。</p>

<p>从美队2里，我们可以看出，这些年来，很多科幻电影正在从《黑客帝国》一般的虚拟世界技术转向了与现实相结合的智能物联。无论是汽车还是电梯，都是传统的物理存在的设备，但是如果加入了智能核心，那么就焕发出超强的生命力。</p>

<p>所以当看到4月21日，百度召开智能硬件峰会的消息时，个人并没有太关注，以为仅仅是发布一些自造或者联营的可穿戴设备，这种活动在最近一两年里，过于常见和泛滥。但是当我看到峰会上推出的Baidu Inside计划，才感到百度对智能硬件领域的野心之大。也许百度未来是想成为智能硬件届的神盾局，将各种各样的天才组合在一起，每个人都有自己的特长，从金刚狼到钢铁侠，但是整体核心是保障美国国土的安全。</p>

<h2>什么是Baidu Inside？</h2>

<p>官方的定义我就不去复述，用更好理解的方式来形容就是”智能电梯，我负责智能，你负责电梯；智能汽车，我负责智能，你负责汽车“。百度用自己的技术接口来与合作伙伴一起拼出一个完美的智能硬件。</p>

<h2>Baidu Inside 包括什么？</h2>

<p>对于开发者而言，其实最关心的是Baidu Inside能提供什么样的技术接口。现在比较受关注的技术接口首先是LBS技术，例如使用百度地图API接口的各种应用共享信息，2亿以上用户以及日均35亿次的定位请求。春节前百度推出的春运迁徙地图就是使用这一接口做的小试牛刀的产品。</p>

<p>其次是百度的语音识别技术。要知道百度有着自己的技术底蕴和基因，加上对人工智能比较重视，去年就成立了百度IDL深度学习研究院。通过技术的研究，使得百度的语音识别错误率大幅度下降。</p>

<p>还有百度的图像识别技术，这也正是百度深度学习研究院（IDL）的主攻方向之一。而在应用层上，从PK大咖到百度魔图，再到能识出物体再翻译的百度翻译，无不是这一技术的不断尝试。要知道，这些交互不过是人工智能的一小部分，百度的深度学习和大数据，要做的是完全的人工智能，未来值得期待的还更多。</p>

<p>另外听说百度内部有个叫”河图“的产品，专门用来将内部技术实现接口化平台化。我的眼前仿佛出现了一幅画卷，汴京街头，熙熙攘攘的人群，一个码农模样的人大喊”河图河图，走过路过不要错过，想上随便上！“</p>

<h2>Baidu Inside计划的背后</h2>

<p>首先Baidu Inside对于百度可以说是基于其自身技术、大数据能力背后的一个平台化计划。毕竟百度核心是一家技术公司，不是一家硬件制造公司，做做手环做做小仪器，还能凭借着质高价更高的供应商生产一些产品出来。但是如果要做复杂程度更高的产品，例如汽车、家居家电等，就完全是百度的短处了。</p>

<p>但是如果百度能把战线集中在智能硬件的内核上，将自己的技术底蕴发挥出来，那么未来哪怕真得想做一个他们愚人节新闻里所说的筷搜产品，也只用做好智能内核，找一个筷子厂代工就好了。</p>

<p>还有就是使用百度内核的产品越多，那么深度学习研究院手里拿到的数据就越多，越有利于机器学习去不断的调整各项技术。这就跟理财是一个道理，如果手里只有100块，不管怎么理财，都很难成为富家翁，如果手里有100万的话，就可以不断的调整理财思路，像滚雪球一样积累财富。</p>

<p>当然，对于普通开发者来说，最大的好处就是可以不用任何事情都从零开始，善于借力善于站在巨人的肩膀上，利用好百度所提供的平台化、接口化服务，就可以让自己的事业事半功倍。</p>

<h2>智能的未来</h2>

<p>智能时代，已经离我们越来越近。很多时候，科幻电影往往会被我们当做未来世界在现在的投影。而一些在科幻电影中出现的设备往往到最后会成为现实，只是所需的时间越来越短。</p>

<p>因为我们正处在一个技术爆炸性发展的时代。ipad的公认原型PADD第一次出现是在1987年的《星际迷航：下一代》中，而ipad到2010年才问世，中间用了23年。而作为残疾人自强不息奋斗不止的优秀代表金刚狼，第一次出现在荧幕上是2000年的《X战警》，他那灵活自如的仿生手臂给很多观众留下了深刻的印象。而在2011年，美国国防部高级研究计划局耗时数年，研发出了一个超级机械手臂，可以完成27种不同的动作来模拟人类的手臂手腕等部位的活动。更让人侧目的是科学家希望在人脑重植入一个芯片来控制手臂的活动，瞬间完成。</p>

<p>所以今天我们在电影里看到的一切，也许明天就出现在我们的身边。例如十年前我们不会相信拿着手机就可以随时随地视频通话，我们也不会相信用电商支付宝分分钟就能购物买东西。那么说不定黑大叔的那辆车过几年就成为大家的标配呢，在北京的任意一条路上堵着，都能大喊一声：“我要去XXX夜总会，起飞！”</p>

<p>目前还无从判断未来BAT哪家公司会屹立于智能时代的顶峰，但是我们已经至少知道，百度正在通过自身的技术能力，开始领跑智能硬件的领域发展，未来百度是否能基于此建立出一套完善的智能技术生态系统，与众多开发者、厂商合作出精彩的智能产品、同赢未来，这点也还有待观望。当我在看到《美国队长2》的最后，黑寡妇想解开系统却权限不够的时候，也突然想到了一个绝佳的产品创意，Baidu Inside应该联合自己的钱包产品，推出一个语音虚拟账户产品。</p>

<p>大概的使用场景是这样的，男人偷偷说一声：”划200块到私房账户。“然后系统语音识别，完美转账。不再需要男人把现金藏在马桶水槽里、婚纱相框背后、餐椅钢管里……并且没有任何物理账户的存在，没有任何蛛丝马迹，老婆想查账也无从查起，小三想查账就告知其权限不够。</p>

<p>智能的未来，男人的福音啊！！！</p>

<p>原文地址：<a href="http://www.woshipm.com/it/80631.html">http://www.woshipm.com/it/80631.html</a></p>

<p class='post-footer'> 文章来源 <a href='http://7hiyo.github.io/blog/2014/04/22/baidu-intelligent/'>http://7hiyo.github.io/blog/2014/04/22/baidu-intelligent/</a><br/>版权所有 <a href='http://7hiyo.github.io'>Z5LINK.Inc</a>&nbsp;posted at <a href='http://7hiyo.github.io'>http://7hiyo.github.io</a><br/>联系我们 <a href='mailto:blog@7hiyo.com'>blog@7hiyo.com</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android的多分辨率适配]]></title>
    <link href="http://7hiyo.github.io/blog/2014/04/15/ios-cocoapods/"/>
    <updated>2014-04-15T14:23:11+08:00</updated>
    <id>http://7hiyo.github.io/blog/2014/04/15/ios-cocoapods</id>
    <content type="html"><![CDATA[<h2>android的分辨率适配</h2>

<hr />

<p>Android手机目前常见的分辨率</p>

<ol>
<li>手机常见分辨率:
4:3

<blockquote><ul>
<li>VGA   640*480 (Video Graphics Array)</li>
<li>QVGA  320*240 (Quarter VGA)</li>
<li>HVGA  480*320 (Half-size VGA)</li>
<li>SVGA  800*600 (Super VGA)</li>
</ul>
</blockquote></li>
</ol>


<!--more-->


<p></p>

<pre><code>5:3
</code></pre>

<blockquote><ul>
<li>WVGA  800*480 (Wide VGA)</li>
</ul>
</blockquote>

<pre><code>16:9
</code></pre>

<blockquote><ul>
<li>FWVGA 854*480 (Full Wide VGA)</li>
<li>HD        1920*1080 High Definition</li>
<li>QHD     960*540</li>
<li>720p    1280*720  标清</li>
<li>1080p  1920*1080 高清</li>
</ul>
</blockquote>

<pre><code>手机:
</code></pre>

<blockquote><ul>
<li>iphone 4/4s    960*640 (3:2)</li>
<li>iphone5         1136*640</li>
<li>小米1             854*480(FWVGA)</li>
<li>小米2             1280*720</li>
</ul>
</blockquote>

<ol>
<li>分辨率对应DPI</li>
</ol>


<blockquote><ul>
<li>&ldquo;HVGA    mdpi&rdquo;</li>
<li>&ldquo;WVGA   hdpi &rdquo;</li>
<li>&ldquo;FWVGA hdpi &rdquo;</li>
<li>&ldquo;QHD      hdpi &rdquo;</li>
<li>&ldquo;720P     xhdpi&rdquo;</li>
<li>&ldquo;1080P   xxhdpi “</li>
</ul>
</blockquote>

<hr />

<h2>屏幕适配的注意事项</h2>

<p> <strong>基本设置</strong></p>

<ul>
<li><p>AndroidManifest.xml设置
   在中Menifest中添加子元素 android:anyDensity=“true&#8221;时，应用程序安装在不同密度的终端上时，程序会分别加载xxhdpi、xhdpi、hdpi、mdpi、ldpi文件夹中的资源；相反，如果设为false，即使在文件夹下拥有相同资源，应用不会自动地去相应文件夹下寻找资源：</p>

<pre><code>   1) 如果drawable-hdpi、drawable-mdpi、drawable-ldpi三个文件夹中有同一张图片资源的不同密度表示，那么系统会去加载drawable_mdpi文件夹中的资源；
   2) 如果drawable-hpdi中有高密度图片，其它两个文件夹中没有对应图片资源，那么系统会去加载drawable-hdpi中的资源，其他同理；
   3) 如果drawable-hdpi,drawable-mdpi中有图片资源，drawable-ldpi中没有，系统会加载drawable-mdpi中的资源，其他同理，使用最接近的密度级别。
</code></pre></li>
<li><p>横屏竖屏目录区分
   1) drawable</p>

<pre><code> a) drawable-hdpi该图片即适用于横屏，也适用于竖屏；
 b) drawable-land-hdpi,当屏幕为横屏，且为高密度时，加载此文件夹的资源；
 c) drawable-port-hdpi,当屏幕为竖屏，且为高密度时，加载此文件夹中的资源。其他同理。
</code></pre></li>
</ul>


<p>  2) layout</p>

<pre><code>      在res目录下建立layout-port和layout-land两个目录，里面分别放置竖屏和横屏两种布局文件，以适应对横屏竖屏自动切换。
</code></pre>

<hr />

<h2>多屏幕适配的4条黄金原则</h2>

<blockquote><p>1) 在layout文件中设置控件尺寸时应采用fill_parent、wrap_content、match_parent和dp；</p>

<pre><code> 具体来说，设置view的属性android:layout_width和android:layout_height的值时，wrap_content，match_parent或dp比px更好，文字大小应该使用sp来定义。
</code></pre>

<p>2) 在程序的代码中不要出现具体的像素值，在dimens.xml中定义；</p>

<pre><code> 为了使代码简单，android内部使用pix为单位表示控件的尺寸，但这是基于当前屏幕基础上的。为了适应多种屏幕，android建议开发者不要使用具体的像素来表示控件尺寸。
</code></pre>

<p>3) 不使用AbsoluteLayout(android1.5已废弃) ，可以使用RelativeLayout替代；</p>

<p>4) 对不同的屏幕提供合适大小的图片。
   不同大小屏幕用不同大小的图片，low:medium:high:extra-high图片大小的比例为3:4:6:8；举例来说，对于中等密度(medium)的屏幕你的图片像素大小为48×48，那么低密度(low)屏幕的图片大小应为36×36，高(high)的为72×72，extra-high为96×96。</p></blockquote>

<p><strong>使用9-patch PNG图片</strong></p>

<pre><code>使用图片资源时，如果出现拉伸，因为图片处理的原因，会变形，导致界面走形。9-patch PNG图片也是一种标准的PGN图片，在原生PNG图片四周空出一个像素间隔，用来标识PNG图片中哪些部分可以拉伸、哪些不可以拉伸、背景上的边框位置等。
“上、左”定义可拉伸区域 ,“右、下”定义显示区域，如果用到完整填充的背景图，建议不要通过android:padding来设置边距，而是通过9-patch方式来定义。
 Android SDK中提供了编辑9-Patch图片的工具，在tools目录下draw9patch.bat，能够立刻看到编辑后的拉伸效果，也可以直接用其他图片编辑工具编辑，但是看不到效果。
</code></pre>

<p><strong>不同的layout</strong></p>

<pre><code>    Android手机屏幕大小不一，有480x320, 640x360, 800x480……，怎样才能让Application自动适应不同的屏幕呢？
    其实很简单，只需要在res目录下创建不同的layout文件夹，比如：layout-640x360、layout-800x480……所有的layout文件在编译之后都会写入R.java里，而系统会根据屏幕的大小自己选择合适的layout进行使用。
</code></pre>

<p>  <strong>测试验证</strong></p>

<pre><code>   一般使用AVD Manager创建多个不同大小的模拟器，如果条件具备，也可以直接用真机测试，这个比较靠谱。当然，Genymotion的模拟器的飞速运行为我们提供了更好的选择，大家可以下载Genymotion的模拟器进行调试。
</code></pre>

<p>3 参考资料</p>

<ul>
<li><p><a href="http://blog.csdn.net/guozh/article/details/8954994">http://blog.csdn.net/guozh/article/details/8954994</a></p></li>
<li><p><a href="http://my.eoe.cn/cainiao1/archive/2348.html">http://my.eoe.cn/cainiao1/archive/2348.html（皇马船长）</a></p></li>
</ul>


<p class='post-footer'> 文章来源 <a href='http://7hiyo.github.io/blog/2014/04/15/ios-cocoapods/'>http://7hiyo.github.io/blog/2014/04/15/ios-cocoapods/</a><br/>版权所有 <a href='http://7hiyo.github.io'>Z5LINK.Inc</a>&nbsp;posted at <a href='http://7hiyo.github.io'>http://7hiyo.github.io</a><br/>联系我们 <a href='mailto:blog@7hiyo.com'>blog@7hiyo.com</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android倒计时类CountDownTimer的使用]]></title>
    <link href="http://7hiyo.github.io/blog/2014/04/14/android-countdowntimer/"/>
    <updated>2014-04-14T13:50:21+08:00</updated>
    <id>http://7hiyo.github.io/blog/2014/04/14/android-countdowntimer</id>
    <content type="html"><![CDATA[<h2>方法一：</h2>

<p>只需要在某个button上点击的时候，触发下面的方法即可：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private void startTimeCount() {
</span><span class='line'>    new CountDownTimer(60000,1000) {
</span><span class='line'>        @Override
</span><span class='line'>        public void onTick(long millisUntilFinished) {
</span><span class='line'>          button.setEnabled(false);
</span><span class='line'>          button.setText(millisUntilFinished/1000+"秒后可重获验证码");
</span><span class='line'>      
</span><span class='line'>        @Override
</span><span class='line'>        public void onFinish() {
</span><span class='line'>          button.setEnabled(true);
</span><span class='line'>          button.setText("重发验证码");
</span><span class='line'>        }
</span><span class='line'>    }.start();</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>其中，button为要显示的文字，当点击后，会出现， <strong><code>x秒后可重获验证码</code></strong>的文字</p>

<h2>方法二：</h2>

<p>使用自定义的方式来实现</p>

<blockquote><p><a href="http://blog.csdn.net/fengbofenglingling/article/details/9840623">android自定义button实现倒计时功能</a></p></blockquote>

<p class='post-footer'> 文章来源 <a href='http://7hiyo.github.io/blog/2014/04/14/android-countdowntimer/'>http://7hiyo.github.io/blog/2014/04/14/android-countdowntimer/</a><br/>版权所有 <a href='http://7hiyo.github.io'>Z5LINK.Inc</a>&nbsp;posted at <a href='http://7hiyo.github.io'>http://7hiyo.github.io</a><br/>联系我们 <a href='mailto:blog@7hiyo.com'>blog@7hiyo.com</a></p>

]]></content>
  </entry>
  
</feed>
